#!/bin/bash

# TODO split into multiple bash functions and re-use some code in taito_impl.sh

# Contain pwd change in a subshell
if ! (

  # Determine parameters
  # TODO this is a quick hack
  if [[ "${1}" == "-dev" ]]; then
    mode=dev
    params=(${@:2})
  elif [[ "${1}" == "-local" ]]; then
    mode=local
    params=(${@:2})
  else
    mode=normal
    params=(${@:1})
  fi

  # Determine docker entrypoint
  # TODO this is a quick hack
  entrypoint="taito"
  if [[ "${1}" == "--shell" ]]; then
    entrypoint="/bin/bash"
    params=()
  elif [[ "${2}" == "--shell" ]]; then
    entrypoint="/bin/bash"
    params=()
  elif [[ "${1}" == "--" ]]; then
    entrypoint="${2}"
    params=(${@:3})
  elif [[ "${2}" == "--" ]]; then
    entrypoint="${3}"
    params=(${@:4})
  fi

  # Resolve project root folder by the location of taito-config.sh
  # Use project root dir as the current working directory
  # TODO duplicate code with taito_impl.sh
  current_path="${PWD}"
  while [[ "${PWD}" != "/" ]]; do
    ls | grep taito-config.sh > /dev/null && break; cd ..;
  done
  if [[ ${PWD} == "/" ]]; then
    cd "${current_path}" || exit 1
  fi

  # Resolve taito-cli location
  # TODO duplicate code with taito_impl.sh
  source="${BASH_SOURCE[0]}"
  while [[ -h "${source}" ]]; do # resolve until the file is no longer a symlink
    dir="$( cd -P "$( dirname "${source}" )" && pwd )"
    source=$(readlink "${source}")
    # if $SOURCE was a relative symlink, we need to resolve it relative
    # to the path where the symlink file was located
    [[ "${source}" != /* ]] && source="${cli_path}/${source}"
  done
  dir_name=$(dirname "${source}")
  cli_path="$( cd -P "${dir_name}" && pwd )"

  # Read taito-config.sh files from all locations
  # TODO duplicate code with taito_impl.sh
  export taito_env="local"
  if [[ -f "${HOME}/.taito/taito-config.sh" ]]; then
    # Personal config
    # shellcheck disable=SC1090
    . "${HOME}/.taito/taito-config.sh"
  fi
  if [[ -f ./taito-config.sh ]]; then
    # Project specific config
    # shellcheck disable=SC1091
    . ./taito-config.sh
  fi

  # Determine command to be executed
  command="${params[0]}"

  # Determine enabled extensions
  extensions_local_mode=""
  extension_paths=""
  extension_mount_flags=""
  exts=("${taito_extensions} ${taito_global_extensions}")
  for extension in ${exts[@]}
  do
    if [[ ${extension} == "git@"* ]]; then
      # Git url e.g. git@github.com:TaitoUnited/webapp-template.git/my-extension
      temp=${extension#*\/}
      repo_url=${extension%.git*}.git # git@github.com:xxx/webapp-template.git
      repo_name=${temp%.git*} # webapp-template
      repo_dir=${temp#*.git} # /my-extension
      repo_local_path="${HOME}/.taito/${repo_name}" # ~/.taito/webapp-template
      if [[ -d "${repo_local_path}" ]]; then
        # Pull the latest version
        if [[ "${command}" == "--upgrade" ]]; then
          echo "Pulling ${repo_local_path}..."
          (cd "${repo_local_path}"; git pull &> /dev/null)
        fi
      else
        (cd ~/.taito; git clone "${repo_url}"; cd "${repo_name}"; git checkout)
      fi
      extension_paths="${extension_paths} /root/.taito/${repo_name}${repo_dir}"
      extensions_local_mode="${extensions_local_mode} \
        ${HOME}/.taito/${repo_name}${repo_dir}"
    elif [[ ${extension} == *"gz" ]]; then
      # Archive link e.g.
      # my-ext-0.5.0=https://github.com/MyOrg/my-ext/archive/v0.5.0.tar.gz
      folder_name=${extension%=*}
      url=${extension##*=}
      if [[ ! -d "${HOME}/.taito/${folder_name}" ]]; then
        echo "Downloading extension ${folder_name} from ${url}"
        ( curl -sL "${url}" | tar zxv -C ~/.taito )
      fi
      extension_paths="${extension_paths} /root/.taito/${repo_name}"
      extensions_local_mode="${extensions_local_mode} \
        ${HOME}/.taito/${repo_name}"
    else
      # Local url
      docker_path="${extension/\~//root}"
      local_path="${extension/\~/${HOME}}"
      extension_paths="${extension_paths} ${docker_path}"
      extension_mount_flags="${extension_mount_flags} \
        -v ${local_path}:${docker_path}"
      extensions_local_mode="${extensions_local_mode} ${local_path}"
    fi
  done

  # Handle taito upgrades
  if [[ "${command}" == "--upgrade" ]]; then
    # Pull latest version of taito bash script
    (cd "${cli_path}"; git pull)

    # Check if taito-cli image has been updated
    SECONDS=0
    docker pull "${taito_image:?}"
    if [[ ${SECONDS} -lt 12 ]]; then
      # Image was not pulled. Using the old image.
      docker image tag "${taito_image}save" \
        "${taito_image}" &> /dev/null
    else
      # Image was pulled -> copy credentials.
      docker rm taito-save taito-new &> /dev/null
      if docker create --name taito-save "${taito_image}save" &> /dev/null; then
        echo "Copying credentials from the old image."
        docker create --name taito-new "${taito_image}"
        mkdir -p ~/.taito/save &> /dev/null
        docker cp taito-save:/root/.config ~/.taito/save
        docker cp taito-save:/root/.kube ~/.taito/save
        docker cp ~/.taito/save/.config taito-new:/root
        docker cp ~/.taito/save/.kube taito-new:/root
        docker commit taito-new "${taito_image}"
        docker image tag "${taito_image}" "${taito_image}save"
        rm -rf ~/.taito/save
        docker rm taito-save taito-new &> /dev/null
      fi
    fi
    exit 0
  fi

  # Prepare execution log files
  mkdir -p "${HOME}/.taito/tmp" &> /dev/null
  log_file=$(mktemp "${HOME}/.taito/tmp/taito-cli.XXXXXX")
  log_file_fg=$(mktemp "${HOME}/.taito/tmp/taito-cli.XXXXXX")
  touch "${log_file}"
  touch "${log_file_fg}"

  # Export some variables to be used by various taito commands
  export taito_host_uname
  taito_host_uname="$(uname)"
  export taito_run="${log_file/${HOME}/\/root}"
  export taito_run_fg="${log_file_fg/${HOME}/\/root}"

  # Start a background process that will run commands on host in the
  # background while the container is still running
  # Commands are read from a log file.
  (
    # Read commands from log file and execute them
    tail -f "${log_file}" | while read -r line; do
      # TODO confirm execution?
      eval "${line}"
    done
  ) &

  # Link database container if env is local and the command uses database
  # TODO: this is a quick hack
  if ( [[ ${command} == *":local" ]] || [[ ${command} != *":"* ]] ) && \
     ( [[ ${command} == db* ]] || [[ ${command} == o-init ]] ) && \
     [[ ${command} != db-add ]]; then
    if [[ ${mode} != "local" ]]; then
      link_flags="--link ${taito_project}-database:${taito_project}-database"
    else
      # Running taito-cli directly on host -> use 127.0.0.1
      export postgres_host_overwrite="127.0.0.1"
    fi
  fi

  # Forward output to 'less' in case the command is `help`, `trouble` or
  # `readme`. We need to also filter some control characters for a cleaner
  # output.
  output=""
  if [[ ${command} == "--help"* ]] || \
     [[ ${command} == "--trouble"* ]] || \
     [[ ${command} == "--readme"* ]]; then
    output="| tr '\r\n' '\275\276' | tr -d '[:cntrl:]' | \
      tr '\275\276' '\r\n' | tail -n +5 | less"
  elif [[ ${params[@]} == *"--help"* ]]; then
    output="| tail -n +5"
  fi

  # Execute command
  if [[ "${mode}" == "local" ]]; then
    # Mode: run directly on host
    export taito_mode="${mode}"
    export taito_enabled_extensions="${extensions_local_mode}"
    eval "${cli_path}/taito_impl.sh ${params[@]} ${output}"
  else
    # Mode: run on docker container
    export taito_image_name
    taito_image_name="${taito_image:?}"
    image_flag="--rm ${taito_image_name}"
    if [[ "${mode}" == "dev" ]]; then
      extension_mount_flags="${extension_mount_flags} \
        -v ${cli_path}:/taito-cli"
    fi

    # Expose ports so that host can access db proxy running on container
    proxy_flags=""
    if [[ "${gcloud_sql_proxy_port:-}" != "" ]]; then
      proxy_flags="\
        --expose=${gcloud_sql_proxy_port} \
        -p 127.0.0.1:${gcloud_sql_proxy_port}:${gcloud_sql_proxy_port}"
    fi

    # Run on docker
    # shellcheck disable=SC2086
    eval "docker run -it \
      --name taito \
      -v \"${HOME}/.taito:/root/.taito\" \
      -v \"$(pwd):/project\" \
      -w /project \
      ${proxy_flags} \
      ${extension_mount_flags} \
      ${link_flags} \
      -e taito_enabled_extensions=\"${extension_paths}\" \
      -e taito_run=${taito_run} \
      -e taito_run_fg=${taito_run_fg} \
      -e taito_host_uname=\"${taito_host_uname}\" \
      -e taito_mode=\"${mode}\" \
      -e taito_docker=\"true\" \
      -e taito_image_name=\"${taito_image_name}\" \
      --entrypoint ${entrypoint} \
      ${image_flag} \
      ${params[@]} ${output}"
  fi

  # Execute requested commands on foreground after container has exited.
  cat "${log_file_fg}" | while read -r line; do
    # TODO confirm execution?
    echo
    echo "------------------------------------------------------------------------------"
    echo
    eval "${line}"
  done

  # Kill the background execution process
  pkill -f "${log_file}"

  # Cleanup
  rm -f "${log_file}" &> /dev/null
  rm -f "${log_file_fg}" &> /dev/null

); then
  exit 1
fi

exit 0
