#!/usr/bin/env bash
# NOTE: This bash script is run directly on host.

# Resolve paths
# NOTE: duplicate with ./taito_impl.sh (taito_cli_path must be resolved before
# other scripts can be called)
export taito_home_path="${TAITO_HOME:-$HOME}"
export taito_cli_path
export taito_src_path
export taito_util_path
export taito_project_path
taito_cli_path=$(
  # Resolve taito-cli path by following symlinks
  source="${BASH_SOURCE[0]}"
  while [[ -h "${source}" ]]; do # resolve until the file is no longer a symlink
    dir="$( cd -P "$( dirname "${source}" )" && pwd )"
    source=$(readlink "${source}")
    [[ "${source}" != /* ]] && source="${taito_cli_path}/${source}"
  done
  dirname "${source}"
)
taito_src_path="${taito_cli_path}/src" && \
taito_util_path="${taito_cli_path}/util" && \
taito_project_path=$("${taito_src_path}/resolve-project-path.sh") && \

# Set working directory
cd "${taito_project_path}" && \

# Read taito-config.sh files from all locations
. "${taito_util_path}/read-taito-config.sh" "local" && \

# Parse arguments
mode="normal"
shell_command=false
continue=false
admin=false
upgrade=false
skip_rest=false
options=()
args=()
while [[ $# -gt 0 ]]
do
  key="$1"
  if [[ ${skip_rest} == false ]]; then
    case $key in
        -d|--dev)
        mode="dev"
        shift
        ;;
        --print-commands)
        mode="print"
        shift
        ;;
        --print-commands-short)
        mode="print-short"
        shift
        ;;
        -c|--continue)
        continue=true
        shift
        ;;
        -a|--admin)
        admin=true
        shift
        ;;
        --upgrade)
        upgrade=true
        shift
        ;;
        *)
        if [[ "$1" == "--" ]]; then
          # shell command: taito -- COMMAND
          shell_command=true
          options+=("$1")
        elif [[ "$1" == "-"* ]]; then
          # not known -> pass it to the docker container as options
          options+=("$1")
        else
          # not an option -> pass this and all the rest to the docker container
          # as args
          args+=("$1")
          skip_rest=true
        fi
        shift
        ;;
    esac
  else
    # Add to args to be passed for the docker container
    args+=("$1")
    shift
  fi
done
# set -- "${args[@]}"

if [[ ${mode} == "print" ]]; then
  "${taito_src_path}/print-commands.sh" "${args[*]}"
  exit 0
fi

if [[ ${mode} == "print-short" ]]; then
  "${taito_src_path}/print-commands-short.sh" "${args[*]}"
  exit 0
fi

if [[ ${continue} == false ]]; then
  echo "Taito-cli Copyright (C) 2017 Taito United"
  echo "This program comes with ABSOLUTELY NO WARRANTY; for details see the LICENSE."
fi

# Convert space command syntax to internal hyphen syntax
if [[ ${shell_command} == false ]];then
  args=($("${taito_src_path}/convert-command-syntax.sh" ${args[@]}))
fi && \

# Determine command and params given to docker container
command=$(echo "${args[0]}" | tr '[:upper:]' '[:lower:]')
params=(${options[@]} ${args[@]})
if [[ -z "${params[*]}" ]]; then
  params=("--help")
fi

# Determine environment
taito_env="local"
if [[ "${command}" == *":"* ]] && [[ "${command}" != *":" ]]; then
  sect="${command##*:}"
  if [[ " local ${taito_environments:-} master " == *" ${sect} "* ]] || \
     [[ "${sect}" == "feat-"* ]]; then
    taito_env="${sect}"
  fi
fi

# Determine user details
taito_container_home="/home/taito"
docker_user_opts="--user $(id -u):$(id -g)"
if [[ ${admin} == true ]]; then
  taito_container_home="/root"
  docker_user_opts=""
  echo "Admin encryption/decryption key:"
  read -s admin_key
  if [[ ${#admin_key} -lt 16 ]]; then
    echo "ERROR: Encyption key must be at least 16 characters long"
    exit 1
  fi
fi

# Determine enabled extensions and download missing remote extensions
extension_paths=""
extension_mount_flags=""
exts=("${taito_extensions} ${taito_global_extensions}")
for extension in ${exts[@]}
do
  if [[ ${extension} == "git@"* ]]; then
    # Git url e.g. git@github.com:TaitoUnited/webapp-template.git/my-extension
    temp=${extension#*\/}
    repo_url=${extension%.git*}.git # git@github.com:xxx/webapp-template.git
    repo_name=${temp%.git*} # webapp-template
    repo_dir=${temp#*.git} # /my-extension
    repo_local_path="${taito_home_path}/.taito/${repo_name}"
    if [[ -d "${repo_local_path}" ]]; then
      # Pull the latest version
      if [[ ${upgrade} == true ]]; then
        echo "Pulling ${repo_local_path}..."
        (
          cd "${repo_local_path}"
          git pull &> /dev/null
        )
      fi
    else
      (
        cd ${taito_home_path}/.taito
        git clone "${repo_url}"
        cd "${repo_name}"
        git checkout
      )
    fi
    extension_paths="${extension_paths} ${taito_container_home}/.taito/${repo_name}${repo_dir}"
  elif [[ ${extension} == *"gz" ]]; then
    # Archive link e.g.
    # my-ext-0.5.0=https://github.com/MyOrg/my-ext/archive/v0.5.0.tar.gz
    folder_name=${extension%=*}
    url=${extension##*=}
    if [[ ! -d "${taito_home_path}/.taito/${folder_name}" ]]; then
      echo "Downloading extension ${folder_name} from ${url}"
      ( curl -sL "${url}" | tar zxv -C ${taito_home_path}/.taito )
    fi
    extension_paths="${extension_paths} ${taito_container_home}/.taito/${repo_name}"
  else
    # Local url
    # First replace ~ with an absolute home path.
    # Then replace home path with ${taito_container_home} for docker.
    local_path="${extension/\~/${taito_home_path}}"
    docker_path="${extension/\~/${taito_home_path}}"
    docker_path="${docker_path/$taito_home_path/$taito_container_home}"
    extension_paths="${extension_paths} ${docker_path}"
    extension_mount_flags="${extension_mount_flags} \
      -v ${local_path}:${docker_path}"
  fi
done

# Handle taito upgrades
if [[ ${upgrade} == true ]]; then
  "${taito_src_path}/taito-upgrade.sh" && \
  exit 0
fi
if [[ "$(docker images -q ${taito_image:?} 2> /dev/null)" == "" ]]; then
  "${taito_src_path}/taito-upgrade.sh"
fi

# Prepare execution log files
mkdir -p "${taito_home_path}/.taito/tmp" &> /dev/null
log_file=$(mktemp "${taito_home_path}/.taito/tmp/taito-cli.XXXXXX")
log_file_fg=$(mktemp "${taito_home_path}/.taito/tmp/taito-cli.XXXXXX")
touch "${log_file}"
touch "${log_file_fg}"

# Set some variables to be used later
taito_host_uname="$(uname)"
taito_run="${log_file/${taito_home_path}/${taito_container_home}}"
taito_run_fg="${log_file_fg/${taito_home_path}/${taito_container_home}}"
if [[ "${taito_host_uname}" == "Darwin" ]]; then
  ctrl_filter=" tr -d '[:cntrl:]' "
else
  ctrl_filter=" grep -axv '.*' "
fi

# Start a background process that will run commands on host in the
# background while the container is still running on foregound.
# Commands to be executed are read from a log file.
(
  # Read commands from log file and execute them
  tail -f "${log_file}" | while read -r line; do
    eval "${line}"
  done
) &

# Link database container if env is local and the command uses database
# TODO: this is an ugly quick hack
link_flags=""
if [[ "${taito_env}" == "local" ]] && \
   [[ "${command}" != "db-add"* ]] && \
   [[ " ${taito_plugins} " == *"-db "* ]] && \
   [[ " ${params[@]} " != *" -h "* ]] && \
   [[ " ${params[@]} " != *" --help "* ]] && \
   (
     [[ "${command}" == "db-"* ]] || \
     [[ "${command}" == "init"* ]]
   ); then
  docker_project="${PWD##*/}"
  if [[ "${docker_legacy_networking}" == "true" ]]; then
    docker_project="${docker_project//-/}"
    docker_project="${docker_project//_/}"
  fi
  networks=("${taito_networks}")
  for network in ${networks[@]}
  do
    link_flags="${link_flags} --network ${docker_project}_${network}"
  done

  # TODO remove links and use networks only
  if [[ "${link_flags}" == "" ]]; then
    databases=("${taito_databases}")
    for database in ${databases[@]}
    do
      echo "# Linking local db: \
        ${taito_project}-${database}:${taito_project}-${database}"
      link_flags="${link_flags} --link \
        ${taito_project}-${database}:${taito_project}-${database}"
    done
  fi
fi

# Prepare docker options
taito_image_name="${taito_image:?}"
image_flag="--rm ${taito_image_name}"
docker_it=""
[[ -t 1 ]] && docker_it="-it"
if [[ "${mode}" == "dev" ]]; then
  extension_mount_flags="${extension_mount_flags} \
    -v ${taito_cli_path}:/taito-cli"
fi
proxy_flags=""
if [[ "${database_proxy_port:-}" != "" ]]; then
  proxy_flags="\
    --expose=${database_proxy_port} \
    -p 127.0.0.1:${database_proxy_port}:${database_proxy_port}"
elif [[ "${gcloud_sql_proxy_port:-}" != "" ]]; then
  # TODO remove gcloud_sql_proxy_port setting from all projects
  proxy_flags="\
    --expose=${gcloud_sql_proxy_port} \
    -p 127.0.0.1:${gcloud_sql_proxy_port}:${gcloud_sql_proxy_port}"
fi

# gcsfuse mounting requires privileged mode
misc_flags=""
if [[ "${command}" == "storage"* ]]; then
  misc_flags="--privileged"
fi

# Forward taito docker container output to 'less' in case the command is `help`,
# `trouble` or `readme`. We need to also filter some control characters for
# a cleaner output.
output=""
if [[ " ${options[*]} " == *" -h "* ]] || \
   [[ " ${options[*]} " == *" --help "* ]] || \
   [[ " ${options[*]} " == *" --trouble "* ]] || \
   [[ " ${options[*]} " == *" --readme "* ]]; then
  output="| tr '\r\n' '\275\276' | ${ctrl_filter} | \
    tr '\275\276' '\r\n' | tail -n +3 | less"
fi

uname_sr="$(uname -sr)"
# For windows we need to make sure that all mounted directories exist
if [[ "${uname_sr}" == *"Microsoft"* ]] || \
   [[ "${uname_sr}" == *"CYGWIN"* ]]; then
  mkdir -p "${taito_home_path}/.taito"
  mkdir -p "${taito_home_path}/.ssh"
  mkdir -p "${taito_home_path}/.terraform.d"
fi

# Execute command in taito docker container
# TODO do not pass taito_admin_key as command line argument
# shellcheck disable=SC2086
eval "docker run ${docker_it} \
  -v \"${taito_home_path}/.taito:${taito_container_home}/.taito\" \
  -v \"${taito_home_path}/.ssh:${taito_container_home}/.ssh\" \
  -v \"${taito_home_path}/.terraform.d:${taito_container_home}/.terraform.d\" \
  -v \"$(pwd):/project\" \
  -w /project \
  ${docker_user_opts} \
  ${proxy_flags} \
  ${extension_mount_flags} \
  ${link_flags} \
  ${misc_flags} \
  -e taito_enabled_extensions=\"${extension_paths}\" \
  -e taito_run=${taito_run} \
  -e taito_run_fg=${taito_run_fg} \
  -e taito_host_uname=\"${taito_host_uname}\" \
  -e taito_host_project_path=\"${taito_project_path}\" \
  -e taito_mode=\"${mode}\" \
  -e taito_docker=\"true\" \
  -e taito_image_name=\"${taito_image_name}\" \
  -e taito_admin_key=\"${admin_key}\" \
  --entrypoint taito \
  ${image_flag} \
  ${params[@]} ${output}"
exit_code=$?

# Kill the background execution process
pkill -f "${log_file}"

# Execute requested commands on foreground after container has exited.
if [[ ${exit_code} == 0 ]]; then
  eval "$(cat "${log_file_fg}")"
  exit_code=$?
fi

# Cleanup
rm -f "${log_file}" &> /dev/null
rm -f "${log_file_fg}" &> /dev/null

# Exit
exit ${exit_code}
